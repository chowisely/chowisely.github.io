---
layout:		post
title:    "[Operating Systems] Interrupt & System Call"
date:     2020-08-20 13:00:00 +0930
tags:     [os]
series:   Operating Systems
comments: true
---

OS의 인터럽트 관리에 대해 알아보자.

---

### "OS is interrupt-driven."

### Interrupt
일반적으로 **인터럽트(interrupt)**는 하드웨어가 어떠한 이벤트를 CPU에게 알리기 위해서 사용하는 방법이다. 하지만 실행 중인 프로세스가 CPU 내의 인터럽트 라인을 세팅하여 인터럽트를 걸기도 한다. 전자를 비동기식 인터럽트(asynchronous interrupt), 후자를 동기식 인터럽트(synchronous interrupt)라고 부른다. **비동기식 인터럽트는 하드웨어**, **동기식 인터럽트는 소프트웨어**에 의해 걸린다고 생각하면 편하다.

종류|설명|예시|
---|---|---|
하드웨어 인터럽트|입출력장치, 타이밍 장치, 전원 등 외부적인 요인에 의해 발생. ISR 종료 후 대기.|키보드, 마우스 입력
소프트웨어 인터럽트(exception or trap)|소프트웨어가 OS 서비스를 요청하거나 에러를 일으켰을 때 발생. ISR 종료 후 다시 프로그램으로 돌아거나 프로그램을 강제로 종료.|파일 읽기/쓰기, 0으로 나누기, 오버플로우

**소프트웨어 인터럽트**는 세 가지로 나뉠 수 있다.

종류|설명|예시|
---|---|---|
Trap|의도적으로 일으킨 예외. ISR 종료 후 실행 재개함.|시스템 콜
Fault|복구가 가능할 수도 있는 예외. ISR 종료 후 실행을 재개할 가능성도 있음.|0으로 나누기, 잘못된 메모리 접근
Abort|복구가 불가능한 예외. ISR 실행 시 프로그램 강제 종료.|하드웨어 고장

---

### Interrupt Service Routine(ISR)
CPU에 인터럽트가 걸리면 **인터럽트 서비스 루틴(interrupt service routine)**에 제어권을 넘겨준다. ISR은 인터럽트의 종류별로 **인터럽트 핸들러(interrupt handler)**의 주소가 담긴 테이블인 **인터럽트 벡터(interrupt vector)**를 보고 어떤 인터럽트가 발생했는지 결정한다. 그리고 해당하는 인터럽트 핸들러의 주소로 이동하여 예외처리를 실행한다.

---

### Dual Mode
일반 사용자가 컴퓨터에 치명적인 명령어를 사용할 수 없도록, 일반 사용자로부터 시스템을 보호하기 위해 하드웨어적으로 **이중 모드(dual mode)**라는 것을 지원한다. 이중 모드는 **사용자 모드(user mode)**와 **커널 모드(kernel mode)**로 나뉜다. 그리고 mode bit(user mode=1, kernel mode=0)를 통해 두 모드를 구분한다. 일반적으로 사용자 프로세스는 사용자 모드에서는 실행되지만 어떤 특정한 명령들은 커널 모드에서만 실행된다. 이 특정한 명령어들을 **특권 명령(privileged instruction)**이라고 하는데 잘못된 접근으로부터 OS와 사용자를 보호하기 위해 모아놓은 명령어들의 집합을 말한다. 여기에 포함된 명령어들은 OS만이 실행할 수 있다.

---

### System Call
만약 CPU가 사용자 프로세스에 포함된 특권 명령을 실행하고자 한다면, 반드시 사용자 모드에서 커널 모드로 전환해야 한다. 프로세스가 특권 명령을 실행하기 위해 **커널 모드로의 전환을 요청하는 인터페이스**를 **시스템 콜(system call)**이라고 한다. 시스템 콜은 trap의 한 종류이기도 하다.

>🔎_프로세스 A가 디스크로부터 파일을 읽어오는 명령을 실행한다고 했을 때 내부적으로 일어나는 과정은 다음과 같다._
1. 프로세스 A가 시스템 콜을 요청하면서 CPU 내에 인터럽트 라인을 세팅한다.
2. CPU는 실행 중이던 명령어를 마치고 인터럽트 라인을 통해 인터럽트가 걸렸음을 인지한다.
3. mode bit를 0으로 바꾸고 OS에게 제어권을 넘긴다.
4. 현재 실행 중이던 프로세서의 상태 및 정보를 PCB(process control block)에 저장한다. 그리고 PC(program counter)에는 다음에 실행할 명령어의 주소를 저장한다.
5. 시스템 콜 루틴에 해당하는 곳으로 점프하고, 시스템 콜 테이블을 참조하여 파일 읽기에 해당하는 시스템 콜을 실행한다.
6. 해당 루틴을 끝내면, mode bit를 1로 바꾸고 PCB에 저장했던 상태들과 PC를 복원시킨다.
7. PC에 저장된 주소(=마지막으로 실행했던 명령어의 다음)로 점프하여 계속 실행한다.

I/O 명령을 실행할 때 CPU의 제어권이 어디로 가냐에 따라 동기식과 비동기식 두 가지로 나뉜다. **동기식 I/O(synchronous I/O)**는 I/O 명령 요청이 완료되어야지만 사용자 프로그램에 제어가 넘어가는 것이다. **비동기식 I/O(asynchronous I/O)**는 I/O 명령이 끝날 때까지 기다리지 않고 사용자 프로그램으로 제어가 넘어가고 I/O가 완료되면 인터럽트로 알린다.

따라서 위의 과정은 동기식 I/O를 기준으로 설명한 것이다. 비동기식 I/O에서는 I/O 명령을 요청하는 5번째부터 조금 다르게 실행된다. 프로세스 A의 정보를 PCB에 저장해두었으므로 다른 프로세스의 PCB를 읽어와서 실행한다. 그리고 I/O 명령을 마치면 디바이스 컨트롤러(device controller)가 CPU에게 인터럽트를 걸 것이다. CPU가 인터럽트를 인지한다면, 실행 중이던 프로세스의 정보를 다시 저장하고  OS에게 제어권을 준다. 그리고 OS는 디바이스 컨트롤러로부터 버퍼에 저장된 데이터를 받아온다. 그리고 I/O를 요청했던 명령어의 메모리 영역에 데이터를 저장하는 과정을 거친다. 프로세스의 상태는 wait에서 ready 상태로 바뀌고 ready queue에 들어가 다음 실행 때까지 기다린다.

---

### Direct Access Memory
많은 양의 데이터를 이동해야 한다면 CPU에게 인터럽트를 많이 걸게 되므로 오버헤드가 발생하게 된다. 오버헤드를 줄이기 위해 CPU의 개입 없이 디바이스 컨트롤러와 메모리 사이에 데이터를 이동하도록 하는 것을 **DMA(direct access memory)**라고 한다.

이 방식을 사용함으로써 얻을 수 있는 점은 CPU가 디바이스와 메모리 사이를 중재할 필요가 사라지기 때문에 CPU는 그동안 다른 일들을 할 수 있다는 것이다. 또한 바이트 단위가 아닌 블록 단위로 인터럽트를 걸기 때문에 오버헤드를 줄일 수 있다.
