[
  
    {
      "title"    : "[BOJ] 1763번 최단경로",
      "title-lower"    : "[boj] 1763번 최단경로",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘다익스트라",
      "tags"     : "알고리즘, 다익스트라",
      "url"      : "/2021/02/23/BOJ-1763.html",
      "date"     : "2021-02-23 11:30:00 +0900",
      "content"     : "문제 바로가기접근다익스트라 문제를 풀 땐 Greedy 기법을 위한 우선순위 큐를 기억해야 한다.크게 연관은 없지만 C++에서 우선순위 큐는 기본적으로 내림차순이다. 따라서 오름차순으로 구현하려면, 우선순위에 마이너스를 붙여주거나 compare 구조체를 따로 만들어야 한다. (ex. vector&amp;lt;Student, vector, comp&amp..."
    } ,
  
    {
      "title"    : "[BOJ] 9663번 N-Queen",
      "title-lower"    : "[boj] 9663번 n-queen",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘구현dfs",
      "tags"     : "알고리즘, 구현, dfs",
      "url"      : "/2021/02/22/BOJ-9663.html",
      "date"     : "2021-02-22 11:30:00 +0900",
      "content"     : "문제 바로가기접근 1N개의 퀸을 서로 공격할 수 없게 N*N 크기의 체스판에 놓는 방법은 한 퀸의 상하좌우, 대각선으로 어떠한 퀸도 놓지 않는 것이다.0번째 행부터 시작해서 가능한 열에 퀸을 놓고, 유망성을 판단하여 해당 노드를 더 탐색해야 하는지 결정한다. 유망성은 이전에 놓은 퀸들의 열 중에서 새로 놓은 퀸의 열과 일치하는 것이 있는지, 이전에 놓..."
    } ,
  
    {
      "title"    : "[BOJ] 6497번 전력난",
      "title-lower"    : "[boj] 6497번 전력난",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘MSTunion-find",
      "tags"     : "알고리즘, MST, union-find",
      "url"      : "/2021/02/15/BOJ-6497.html",
      "date"     : "2021-02-15 11:30:00 +0900",
      "content"     : "문제 바로가기접근우선순위 큐에 길 정보를 모두 담고 Kruskal 알고리즘으로 풀면 되는데, 절약할 수 있는 최대 비용을 구하는 거라 모든 길의 합에서 연결시킨 길의 합을 뺀 값을 구해야 한다.#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;struct Edge {  int x;  int y;  ..."
    } ,
  
    {
      "title"    : "[BOJ] 2512번 예산",
      "title-lower"    : "[boj] 2512번 예산",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘이분탐색",
      "tags"     : "알고리즘, 이분탐색",
      "url"      : "/2021/02/11/BOJ-2512.html",
      "date"     : "2021-02-11 11:30:00 +0900",
      "content"     : "문제 바로가기접근이분 탐색으로 풀 때 초기 탐색의 low와 high를 어떤 값으로 할지 잘 생각하고 풀어야 한다.이 문제에서는 어떠한 지방에게도 요청한 금액을 주지 못할 수도 있으므로 low를 0으로 설정해야 한다.#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;int N;long long M;v..."
    } ,
  
    {
      "title"    : "[BOJ] 17135번 캐슬 디펜스",
      "title-lower"    : "[boj] 17135번 캐슬 디펜스",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘구현dfs",
      "tags"     : "알고리즘, 구현, dfs",
      "url"      : "/2021/02/05/BOJ-17135.html",
      "date"     : "2021-02-05 11:30:00 +0900",
      "content"     : "문제 바로가기[삼성 역량 테스트 A형 기출문제]접근삼성 역테답게 구현+그래프 탐색의 조합으로 푸는 문제다.궁수를 배치할 수 있는 경우의 수에 대하여 시뮬레이션을 한 뒤, 적을 제외시킬 수 있는 최대값을 구하면 되겠다. 고려해야 할 점으로는, 모든 궁수들이 적을 선택한 후에 적을 제외한다는 것(동일한 적이 존재할 수 있음)과 같은 거리에 있는 적이 여럿..."
    } ,
  
    {
      "title"    : "[BOJ] 17472번 다리 만들기 2",
      "title-lower"    : "[boj] 17472번 다리 만들기 2",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘구현bfs",
      "tags"     : "알고리즘, 구현, bfs",
      "url"      : "/2021/02/04/BOJ-17472.html",
      "date"     : "2021-02-04 11:30:00 +0900",
      "content"     : "문제 바로가기접근BFS로 각각의 섬들에 번호를 부여한 뒤, 임의의 두 섬을 이을 수 있는 간선들(길이 &amp;gt;= 2)을 우선순위 큐에 담았다. 이후에는 최소 스패닝 트리를 구하는 과정과 동일하다.두 섬을 잇는 간선은 상하좌우 네 방향에 대해서 탐색하도록 한다.#include &amp;lt;bits/stdc++.h&amp;gt;using name..."
    } ,
  
    {
      "title"    : "[BOJ] 11559번 Puyo Puyo",
      "title-lower"    : "[boj] 11559번 puyo puyo",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘구현bfs",
      "tags"     : "알고리즘, 구현, bfs",
      "url"      : "/2021/02/03/BOJ-11559.html",
      "date"     : "2021-02-03 11:30:00 +0900",
      "content"     : "문제 바로가기접근그래프 탐색을 응용하는 구현 문제이다.전체 맵에서 한 번 훑어 터트릴 수 있는 뿌요를 벡터에 모두 담아준다. 훑은 다음, 벡터에 담겨 있는 모든 위치를 빈 공간으로 만들고, 바닥과 뿌요 사이에 빈 공간이 남지 않을 때까지 뿌요들을 내려준다.#include &amp;lt;bits/stdc++.h&amp;gt;using namespace ..."
    } ,
  
    {
      "title"    : "[BOJ] 2636번 치즈",
      "title-lower"    : "[boj] 2636번 치즈",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘구현bfs",
      "tags"     : "알고리즘, 구현, bfs",
      "url"      : "/2021/01/30/BOJ-2636.html",
      "date"     : "2021-01-30 11:30:00 +0900",
      "content"     : "문제 바로가기접근이 문제의 핵심은 치즈의 구멍이라고 생각한다. 처음에는 사방이 치즈로 둘러싸여 있지 않다면 녹을 차례라고 생각했는데, 치즈의 구멍을 간과했었다.치즈의 구멍을 고려해서 풀어보면, 판의 가장자리인 (0,0)은 항상 치즈가 놓여 있지 않으므로 해당 지점을 시작으로 BFS로 탐색을 한다.한 번 탐색이 끝났을 때 치즈가 놓인 곳에 방문 표시가 ..."
    } ,
  
    {
      "title"    : "[BOJ] 15684번 사다리 조작",
      "title-lower"    : "[boj] 15684번 사다리 조작",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘구현dfs",
      "tags"     : "알고리즘, 구현, dfs",
      "url"      : "/2021/01/28/BOJ-15684.html",
      "date"     : "2021-01-28 11:30:00 +0900",
      "content"     : "문제 바로가기접근DFS를 사용해 사다리 개수를 0개부터 3개까지 놓아본다. 최소 사다리 개수를 구하는 것이므로 길을 찾기만 한다면, 그게 답이 된다.(처음에는 DFS 한 번 불러서 가능한 모든 경우의 수를 탐색하고 답을 구했는데, 생각해보니 그럴 필요가 없었다.)한 가지 고려해야 할 점은, 사다리를 놓을 때 좌우에 사다리가 존재하면 안된다는 조건이다...."
    } ,
  
    {
      "title"    : "[BOJ] 2563번 색종이",
      "title-lower"    : "[boj] 2563번 색종이",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘구현",
      "tags"     : "알고리즘, 구현",
      "url"      : "/2021/01/27/BOJ-2563.html",
      "date"     : "2021-01-27 11:30:00 +0900",
      "content"     : "문제 바로가기접근도화지 크기의 배열을 잡고 색종이가 해당하는 경우 1을 주어서 모든 1을 카운트하면 된다.#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;int main() {  std::ios::sync_with_stdio(false);  cin.tie(NULL); cout.tie(NULL); ..."
    } ,
  
    {
      "title"    : "[BOJ] 4386번 별자리 만들기",
      "title-lower"    : "[boj] 4386번 별자리 만들기",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘MSTunion-find",
      "tags"     : "알고리즘, MST, union-find",
      "url"      : "/2021/01/26/BOJ-4386.html",
      "date"     : "2021-01-26 11:30:00 +0900",
      "content"     : "문제 바로가기접근별의 최대 개수가 100개이므로 이 별들을 잇는 최대 간선의 수는 100*(100-1)/2이다.크지 않은 수라 가능한 모든 간선을 우선순위 큐에 넣어 Kruskal 알고리즘을 사용했다.#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;struct Edge {  int n1;  int..."
    } ,
  
    {
      "title"    : "[BOJ] 2887번 행성 터널",
      "title-lower"    : "[boj] 2887번 행성 터널",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘MSTunion-find",
      "tags"     : "알고리즘, MST, union-find",
      "url"      : "/2021/01/25/BOJ-2887.html",
      "date"     : "2021-01-25 11:30:00 +0900",
      "content"     : "문제 바로가기접근처음에 프림 알고리즘으로 풀었다가 최대 간선의 수가 n이 100,000일 때인 100,000*(100,000-1)/2라 시간 초과가 떴다.바꾼 풀이법은, 먼저 행성의 위치를 x를 기준으로 정렬한다. (x를 기준으로 행성들을 일직선 상 위에 놓여있는 것과 같다.) 그리고 idx와 idx + 1의 두 행성을 x 좌표로 이을 때 비용을 저장..."
    } ,
  
    {
      "title"    : "[Architecture] Summary",
      "title-lower"    : "[architecture] summary",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "architecture",
      "tags"     : "architecture",
      "url"      : "/2020/10/10/ComputerArchitecture-Summary.html",
      "date"     : "2020-10-10 11:30:00 +0900",
      "content"     : "Computer Architecture SummaryBackgroundMoore의 법칙반도체 칩에 들어가는 트랜지스터의 수는 매년 지수적으로 증가한다. (미세화의 한계로 이제는 적용되지 X)Amdahl의 법칙Performance = 1 / ((1 - P) + P / S)(P=전체에서 개선된 부분이 차지하는 비율, S=이전에 비해 성능이 향상한 정도)컴..."
    } ,
  
    {
      "title"    : "[Architecture] Virtualization",
      "title-lower"    : "[architecture] virtualization",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "architecture",
      "tags"     : "architecture",
      "url"      : "/2020/10/07/ComputerArchitecture-MemoryHierarchy.html",
      "date"     : "2020-10-07 11:30:00 +0900",
      "content"     : "메모리 계층 구조에 대해 알아보자.Memory Hierarchy만약 속도가 빠르고, 크기가 크고, 가격이 싼 메모리를 개발할 수 있는 기술이 있다면 메모리 계층 구조(memory hierarchy) 개념이 등장하지 않았을 것이다. 하지만 일반적으로 속도가 빠르면 가격이 비싸지고, 크기가 커지면 속도가 느려지는 메모리의 한계점을 해결하지 못한다. 따라서..."
    } ,
  
    {
      "title"    : "[Architecture] MIPS &amp; Datapath &amp; Hazard",
      "title-lower"    : "[architecture] mips &amp; datapath &amp; hazard",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "architecture",
      "tags"     : "architecture",
      "url"      : "/2020/10/06/ComputerArchitecture-MIPSDatapathHazard.html",
      "date"     : "2020-10-06 12:00:00 +0900",
      "content"     : "몇 가지의 datapath와 그에 관련한 hazard를 알아보자.Procedure Calling프로시저를 부르는 곳을 caller, 호출되는 프로시저를 callee라고 한다. caller와 callee 모두 같은 레지스터를 사용하기 때문에 서로의 레지스터 값을 보호하기 위해 두 가지 방법이 사용된다.Caller Save vs. Callee SaveCa..."
    } ,
  
    {
      "title"    : "[Architecture] Performance",
      "title-lower"    : "[architecture] performance",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "architecture",
      "tags"     : "architecture",
      "url"      : "/2020/10/06/ComputerArchitecture-Performance.html",
      "date"     : "2020-10-06 11:30:00 +0900",
      "content"     : "컴퓨터 아키텍쳐의 성능에 영향을 미치는 요인들을 파악하자.PerformanceTimewall-clock time, response time, elapsed time, CPU timeCPU TimeCPU Time = CPU time spent for a given program= Cycles/Program (=Clock Cycles) * Seconds/..."
    } ,
  
    {
      "title"    : "[Architecture] Virtualization",
      "title-lower"    : "[architecture] virtualization",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "architecture",
      "tags"     : "architecture",
      "url"      : "/2020/10/05/ComputerArchitecture-Virtualization.html",
      "date"     : "2020-10-05 11:30:00 +0900",
      "content"     : "“반도체 칩에 들어가는 트랜지스터의 수는 시간의 흐름에 따라 지수적으로 증가했다. 하지만 CPU에서는 performance, DRAM에서는 capacity를 높이는 용도로 서로의 지향점이 달랐다. 이는 결국 CPU와 DRAM의 속도 차이를 야기했고, 이 간격을 메우기 위해 캐시가 등장했다.”“트랜지스터가 작아짐에 따라 reliability가 떨어진다...."
    } ,
  
    {
      "title"    : "[Algorithm] Sorting - Shortest Path",
      "title-lower"    : "[algorithm] sorting - shortest path",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "algorithmsort",
      "tags"     : "algorithm, sort",
      "url"      : "/2020/08/29/Algorithm-ShortestPath.html",
      "date"     : "2020-08-29 13:00:00 +0900",
      "content"     : "이 글에서 다룰 최단 거리를 구하는 알고리즘은 두 가지 종류로 나눌 수 있다.      Single Source Shortest Path: 모든 정점의 집합을 V라고 했을 때, 주어진 정점 s ∈ V에 대하여 모든 정점 t ∈ V로 가는 거리를 구한다.    All Pairs Shortest Path: 모든 정점 s ∈ V에 대하여 모든 정점 t ∈ ..."
    } ,
  
    {
      "title"    : "[Algorithm] Sorting - Time Complexity O(N)",
      "title-lower"    : "[algorithm] sorting - time complexity o(n)",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "algorithmsort",
      "tags"     : "algorithm, sort",
      "url"      : "/2020/08/29/Algorithm-Sorting3.html",
      "date"     : "2020-08-29 12:30:00 +0900",
      "content"     : "시간 복잡도가 O(N)인 정렬 알고리즘을 하나를 알아보자.Counting Sort특이하게도 counting sort는 정렬 알고리즘이지만 비교 연산을 하지 않는다. 이름처럼 해당 숫자를 ‘카운팅’할 뿐이다. 정렬하고자 하는 숫자들의 범위가 주어져야 하는 것이 조건이다.[3,2,2,1,4,1] (4 이하의 음이 아닌 정수들이라는 조건이 미리 주어진다.)..."
    } ,
  
    {
      "title"    : "[Algorithm] Sorting - Time Complexity O(NlogN)",
      "title-lower"    : "[algorithm] sorting - time complexity o(nlogn)",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "algorithmsort",
      "tags"     : "algorithm, sort",
      "url"      : "/2020/08/29/Algorithm-Sorting2.html",
      "date"     : "2020-08-29 12:00:00 +0900",
      "content"     : "지난 글에 이어서 이번 글은 시간 복잡도가 O(NlogN)인 알고리즘을 정리해보았다.Quick SortQuick sort가 시간 복잡도를 NlogN으로 줄일 수 있는 이유는 Divide and Conquer 접근법을 이용했기 때문이다. (Divide and Conquer 접근법이란 큰 문제를 여러 하위 문제로 쪼개고, 각 문제의 솔루션들을 구해서 하나..."
    } ,
  
    {
      "title"    : "[Algorithm] Sorting - Time Complexity O(N^2)",
      "title-lower"    : "[algorithm] sorting - time complexity o(n^2)",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "algorithmsort",
      "tags"     : "algorithm, sort",
      "url"      : "/2020/08/29/Algorithm-Sorting1.html",
      "date"     : "2020-08-29 11:30:00 +0900",
      "content"     : "알고리즘 수업을 들은지 1년이 지났지만 여러 정렬 알고리즘을 아직까지 제대로 모른다는 생각이 들었다. 이번을 기회로 삼아 7가지 정렬 알고리즘을 공부했고, 시간 복잡도가 높은 순서대로 정리해보았다.(* 모든 정렬은 오름차순을 기준이다.)Selection Sort배열에 나열된 요소를 쭉 훑어 가장 작은 수를 찾아내고 그것을 앞으로 보내는 것이다. 이 과..."
    } ,
  
    {
      "title"    : "[Compiler Theory] Top-Down Parsing",
      "title-lower"    : "[compiler theory] top-down parsing",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "compiler",
      "tags"     : "compiler",
      "url"      : "/2020/08/22/CompilerTheory-TopDownParsing.html",
      "date"     : "2020-08-22 12:30:00 +0900",
      "content"     : "하향식 구문 분석에 대해 알아보자.하향식 구문 분석(top-down parsing)는 시작 기호부터 좌단 유도를 적용하면서 문장을 찾는다. 파스 트리는 루트 노드에서 시작해 터미널 노드까지 확장해 나간다. 상향식 구문 분석(bottom-up parsing)에 비해 구현이 간단하지만 역추적(backtracking) 문제 때문에 잘 사용되지 않는다.하향식..."
    } ,
  
    {
      "title"    : "[Compiler Theory] Ambiguous Grammar",
      "title-lower"    : "[compiler theory] ambiguous grammar",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "compiler",
      "tags"     : "compiler",
      "url"      : "/2020/08/22/CompilerTheory-AmbiguousGrammar.html",
      "date"     : "2020-08-22 12:00:00 +0900",
      "content"     : "모호한 문법에 대해 알아보자.좌단 유도(leftmost derivation) 혹은 우단 유도(rightmost derivation)를 적용했을 때 하나의 문장에 대하여 두 개 이상의 파스 트리(parse tree)가 생성될 때 모호한 문법(ambiguous grammar)이라고 한다.모호한 문법으로 파스 트리를 결정적으로 생성하기 위해서는 두가지 방법..."
    } ,
  
    {
      "title"    : "[Compiler Theory] Chomsky Hierarchy",
      "title-lower"    : "[compiler theory] chomsky hierarchy",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "compiler",
      "tags"     : "compiler",
      "url"      : "/2020/08/22/CompilerTheory-ChomskyHierarchy.html",
      "date"     : "2020-08-22 11:30:00 +0900",
      "content"     : "촘스키 계층 구조에 대해 알아보자.            Type      Name      Rule      Recognizer                  0      Recursively Enummerable Language      아무런 제약이 없음      Turing Machine              1      Context Sens..."
    } ,
  
    {
      "title"    : "[Operating Systems] Memory Management 1",
      "title-lower"    : "[operating systems] memory management 1",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "os",
      "tags"     : "os",
      "url"      : "/2020/08/20/OS-MemoryManagement1.html",
      "date"     : "2020-08-20 14:30:00 +0900",
      "content"     : "OS의 메모리 관리 역할에 대해 알아보자.OS는 사용자에게 메모리에 대한 추상화를 제공할 뿐만 아니라 메모리 관리(memory management)를 통해 한정된 메모리 자원을 효율적으로 사용하고 메모리를 보호한다. 또한 메모리 관리는 각 프로세스들에 할당된 메모리 정보와 비어있는 메모리 공간에 대한 정보 관리를 포함한다.메모리를 효율적으로 사용한다는..."
    } ,
  
    {
      "title"    : "[Operating Systems] Process &amp; Thread",
      "title-lower"    : "[operating systems] process &amp; thread",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "os",
      "tags"     : "os",
      "url"      : "/2020/08/20/OS-Process-Thread.html",
      "date"     : "2020-08-20 13:30:00 +0900",
      "content"     : "OS의 프로세스 및 스레드 관리에 대해 알아보자.프로세스란 실행 중인 프로그램을 의미한다. 프로세스는 PC와 레지스터를 포함한 현재 상태, 텍스트(=프로그램 코드), 스택(=임시 데이터), 데이터(=전역 변수), 힙으로 이루어져 있다.Process State위 그림은 프로세스의 상태 변화를 나타낸 그림으로 총 5가지 상태로 나눌 수 있다.New: 프로..."
    } ,
  
    {
      "title"    : "[Operating Systems] Interrupt &amp; System Call",
      "title-lower"    : "[operating systems] interrupt &amp; system call",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "os",
      "tags"     : "os",
      "url"      : "/2020/08/20/OS-Interrupt-SystemCall.html",
      "date"     : "2020-08-20 12:30:00 +0900",
      "content"     : "OS의 인터럽트 관리에 대해 알아보자.“OS is interrupt-driven.”Interrupt일반적으로 인터럽트(interrupt)는 하드웨어가 어떠한 이벤트를 CPU에게 알리기 위해서 사용하는 방법이다. 하지만 실행 중인 프로세스가 CPU 내의 인터럽트 라인을 세팅하여 인터럽트를 걸기도 한다. 전자를 비동기식 인터럽트(asynchronous i..."
    } ,
  
    {
      "title"    : "[Operating Systems] Introduction",
      "title-lower"    : "[operating systems] introduction",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "os",
      "tags"     : "os",
      "url"      : "/2020/08/20/OS-Introduction.html",
      "date"     : "2020-08-20 11:30:00 +0900",
      "content"     : "컴퓨터에 OS가 없다면 어떤 일이 일어나게 될까. 누군가가 이러한 컴퓨터의 상태를 달리는 방법을 모르는 말이라고 했다. 왜 그렇게 비유를 들었는지 이 글을 정리하는 시점에서 이해가 가려한다. 이 글에서는 컴퓨터가 프로그램을 실행하기까지 어떠한 과정을 거치는지, OS는 무엇이고 어떤 역할을 하는지에 대한 내용을 다루어보았다.위 그림은 하나의 프로그램이 ..."
    } ,
  
    {
      "title"    : "[Compiler Theory] Introduction",
      "title-lower"    : "[compiler theory] introduction",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "compiler",
      "tags"     : "compiler",
      "url"      : "/2020/08/17/CompilerTheory-Introduction.html",
      "date"     : "2020-08-17 11:30:00 +0900",
      "content"     : "컴파일로 이론 개요에 대해 살펴보자.지난 학기에 배웠던 컴파일러 수업을 며칠 동안 되짚어 보며 복습을 했다. 근 몇 주 동안 배웠던 과목들을 다시 공부하면서 계속 느끼는 게, 시간이 지나 다시 보니 새롭기도 하지만 이제는 큰 틀을 그릴 수 있겠다는 거다. 그래서 잊어버릴 때마다 두고두고 볼 수 있도록 글을 쓰려 한다.일반적으로 사용되고 있는 컴파일러는..."
    } 
  
]
