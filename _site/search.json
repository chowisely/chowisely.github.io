[
  
    {
      "title"    : "[BOJ] 15684번 사다리 조작",
      "title-lower"    : "[boj] 15684번 사다리 조작",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘구현DFS",
      "tags"     : "알고리즘, 구현, DFS",
      "url"      : "/2021/01/27/BOJ-15684.html",
      "date"     : "2021-01-27 11:30:00 +0900",
      "content"     : "문제 바로가기접근DFS를 사용해 사다리 개수를 0개부터 3개까지 놓아본다. 최소 사다리 개수를 구하는 것이므로 길을 찾기만 한다면, 그게 답이 된다.(처음에는 DFS 한 번 불러서 가능한 모든 경우의 수를 탐색하고 답을 구했는데, 생각해보니 그럴 필요가 없었다.)한 가지 고려해야 할 점은, 사다리를 놓을 때 좌우에 사다리가 존재하면 안된다는 조건이다...."
    } ,
  
    {
      "title"    : "[BOJ] 2563번 색종이",
      "title-lower"    : "[boj] 2563번 색종이",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘구현",
      "tags"     : "알고리즘, 구현",
      "url"      : "/2021/01/27/BOJ-2563.html",
      "date"     : "2021-01-27 11:30:00 +0900",
      "content"     : "문제 바로가기접근도화지 크기의 배열을 잡고 색종이가 해당하는 경우 1을 주어서 모든 1을 카운트하면 된다.#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;int main() {  std::ios::sync_with_stdio(false);  cin.tie(NULL); cout.tie(NULL); ..."
    } ,
  
    {
      "title"    : "[BOJ] 4386번 별자리 만들기",
      "title-lower"    : "[boj] 4386번 별자리 만들기",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘MSTunion-find",
      "tags"     : "알고리즘, MST, union-find",
      "url"      : "/2021/01/26/BOJ-4386.html",
      "date"     : "2021-01-26 11:30:00 +0900",
      "content"     : "문제 바로가기접근별의 최대 개수가 100개이므로 이 별들을 잇는 최대 간선의 수는 100*(100-1)/2이다.크지 않은 수라 가능한 모든 간선을 우선순위 큐에 넣어 Kruskal 알고리즘을 사용했다.#include &amp;lt;bits/stdc++.h&amp;gt;using namespace std;struct Edge {  int n1;  int..."
    } ,
  
    {
      "title"    : "[BOJ] 2887번 행성 터널",
      "title-lower"    : "[boj] 2887번 행성 터널",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "알고리즘MSTunion-find",
      "tags"     : "알고리즘, MST, union-find",
      "url"      : "/2021/01/25/BOJ-2887.html",
      "date"     : "2021-01-25 11:30:00 +0900",
      "content"     : "문제 바로가기접근처음에 프림 알고리즘으로 풀었다가 최대 간선의 수가 n이 100,000일 때인 100,000*(100,000-1)/2라 시간 초과가 떴다.바꾼 풀이법은, 먼저 행성의 위치를 x를 기준으로 정렬한다. (x를 기준으로 행성들을 일직선 상 위에 놓여있는 것과 같다.) 그리고 idx와 idx + 1의 두 행성을 x 좌표로 이을 때 비용을 저장..."
    } ,
  
    {
      "title"    : "[Architecture] Summary",
      "title-lower"    : "[architecture] summary",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "architecture",
      "tags"     : "architecture",
      "url"      : "/2020/10/10/ComputerArchitecture-Summary.html",
      "date"     : "2020-10-10 11:30:00 +0900",
      "content"     : "Computer Architecture SummaryBackgroundMoore의 법칙반도체 칩에 들어가는 트랜지스터의 수는 매년 지수적으로 증가한다. (미세화의 한계로 이제는 적용되지 X)Amdahl의 법칙Performance = 1 / ((1 - P) + P / S)(P=전체에서 개선된 부분이 차지하는 비율, S=이전에 비해 성능이 향상한 정도)컴..."
    } ,
  
    {
      "title"    : "[Architecture] Virtualization",
      "title-lower"    : "[architecture] virtualization",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "architecture",
      "tags"     : "architecture",
      "url"      : "/2020/10/07/ComputerArchitecture-MemoryHierarchy.html",
      "date"     : "2020-10-07 11:30:00 +0900",
      "content"     : "메모리 계층 구조에 대해 알아보자.Memory Hierarchy만약 속도가 빠르고, 크기가 크고, 가격이 싼 메모리를 개발할 수 있는 기술이 있다면 메모리 계층 구조(memory hierarchy) 개념이 등장하지 않았을 것이다. 하지만 일반적으로 속도가 빠르면 가격이 비싸지고, 크기가 커지면 속도가 느려지는 메모리의 한계점을 해결하지 못한다. 따라서..."
    } ,
  
    {
      "title"    : "[Architecture] MIPS &amp; Datapath &amp; Hazard",
      "title-lower"    : "[architecture] mips &amp; datapath &amp; hazard",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "architecture",
      "tags"     : "architecture",
      "url"      : "/2020/10/06/ComputerArchitecture-MIPSDatapathHazard.html",
      "date"     : "2020-10-06 12:00:00 +0900",
      "content"     : "몇 가지의 datapath와 그에 관련한 hazard를 알아보자.Procedure Calling프로시저를 부르는 곳을 caller, 호출되는 프로시저를 callee라고 한다. caller와 callee 모두 같은 레지스터를 사용하기 때문에 서로의 레지스터 값을 보호하기 위해 두 가지 방법이 사용된다.Caller Save vs. Callee SaveCa..."
    } ,
  
    {
      "title"    : "[Architecture] Performance",
      "title-lower"    : "[architecture] performance",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "architecture",
      "tags"     : "architecture",
      "url"      : "/2020/10/06/ComputerArchitecture-Performance.html",
      "date"     : "2020-10-06 11:30:00 +0900",
      "content"     : "컴퓨터 아키텍쳐의 성능에 영향을 미치는 요인들을 파악하자.PerformanceTimewall-clock time, response time, elapsed time, CPU timeCPU TimeCPU Time = CPU time spent for a given program= Cycles/Program (=Clock Cycles) * Seconds/..."
    } ,
  
    {
      "title"    : "[Architecture] Virtualization",
      "title-lower"    : "[architecture] virtualization",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "architecture",
      "tags"     : "architecture",
      "url"      : "/2020/10/05/ComputerArchitecture-Virtualization.html",
      "date"     : "2020-10-05 11:30:00 +0900",
      "content"     : "“반도체 칩에 들어가는 트랜지스터의 수는 시간의 흐름에 따라 지수적으로 증가했다. 하지만 CPU에서는 performance, DRAM에서는 capacity를 높이는 용도로 서로의 지향점이 달랐다. 이는 결국 CPU와 DRAM의 속도 차이를 야기했고, 이 간격을 메우기 위해 캐시가 등장했다.”“트랜지스터가 작아짐에 따라 reliability가 떨어진다...."
    } ,
  
    {
      "title"    : "[Algorithm] Sorting - Shortest Path",
      "title-lower"    : "[algorithm] sorting - shortest path",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "algorithmsort",
      "tags"     : "algorithm, sort",
      "url"      : "/2020/08/29/Algorithm-ShortestPath.html",
      "date"     : "2020-08-29 13:00:00 +0900",
      "content"     : "이 글에서 다룰 최단 거리를 구하는 알고리즘은 두 가지 종류로 나눌 수 있다.      Single Source Shortest Path: 모든 정점의 집합을 V라고 했을 때, 주어진 정점 s ∈ V에 대하여 모든 정점 t ∈ V로 가는 거리를 구한다.    All Pairs Shortest Path: 모든 정점 s ∈ V에 대하여 모든 정점 t ∈ ..."
    } ,
  
    {
      "title"    : "[Algorithm] Sorting - Time Complexity O(N)",
      "title-lower"    : "[algorithm] sorting - time complexity o(n)",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "algorithmsort",
      "tags"     : "algorithm, sort",
      "url"      : "/2020/08/29/Algorithm-Sorting3.html",
      "date"     : "2020-08-29 12:30:00 +0900",
      "content"     : "Counting Sort특이하게도 counting sort는 정렬 알고리즘이지만 비교 연산을 하지 않는다. 이름처럼 해당 숫자를 ‘카운팅’할 뿐이다. 정렬하고자 하는 숫자들의 범위가 주어져야 하는 것이 조건이다.[3,2,2,1,4,1] (4 이하의 음이 아닌 정수들이라는 조건이 미리 주어진다.)각 숫자의 값들을 인덱스라고 하고, 해당하는 인덱스에 위치..."
    } ,
  
    {
      "title"    : "[Algorithm] Sorting - Time Complexity O(NlogN)",
      "title-lower"    : "[algorithm] sorting - time complexity o(nlogn)",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "algorithmsort",
      "tags"     : "algorithm, sort",
      "url"      : "/2020/08/29/Algorithm-Sorting2.html",
      "date"     : "2020-08-29 12:00:00 +0900",
      "content"     : "지난 글에 이어서 이번 글은 시간 복잡도가 O(NlogN)인 알고리즘을 정리해보았다.Quick SortQuick sort가 시간 복잡도를 NlogN으로 줄일 수 있는 이유는 Divide and Conquer 접근법을 이용했기 때문이다. (Divide and Conquer 접근법이란 큰 문제를 여러 하위 문제로 쪼개고, 각 문제의 솔루션들을 구해서 하나..."
    } ,
  
    {
      "title"    : "[Algorithm] Sorting - Time Complexity O(N^2)",
      "title-lower"    : "[algorithm] sorting - time complexity o(n^2)",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "algorithmsort",
      "tags"     : "algorithm, sort",
      "url"      : "/2020/08/29/Algorithm-Sorting1.html",
      "date"     : "2020-08-29 11:30:00 +0900",
      "content"     : "알고리즘 수업을 들은지 1년이 지났지만 여러 정렬 알고리즘을 아직까지 제대로 모른다는 생각이 들었다. 이번을 기회로 삼아 7가지 정렬 알고리즘을 공부했고, 시간 복잡도가 높은 순서대로 정리해보았다.(* 모든 정렬은 오름차순을 기준이다.)Selection Sort배열에 나열된 요소를 쭉 훑어 가장 작은 수를 찾아내고 그것을 앞으로 보내는 것이다. 이 과..."
    } ,
  
    {
      "title"    : "[Compiler Theory] Introduction",
      "title-lower"    : "[compiler theory] introduction",
      "sub-titile" : "",
      "sub-titile-lower" : "",
      "categories" : "compiler",
      "tags"     : "compiler",
      "url"      : "/2020/08/17/CompilerTheory-Introduction.html",
      "date"     : "2020-08-17 11:30:00 +0900",
      "content"     : "지난 학기에 배웠던 컴파일러 수업을 며칠 동안 되짚어 보며 복습을 했다. 근 몇 주 동안 배웠던 과목들을 다시 공부하면서 계속 느끼는 게, 시간이 지나 다시 보니 새롭기도 하지만 이제는 큰 틀을 그릴 수 있겠다는 거다. 그래서 잊어버릴 때마다 두고두고 볼 수 있도록 글을 쓰려 한다.일반적으로 사용되고 있는 컴파일러는 2-패스 컴파일러로 IR(inter..."
    } 
  
]
